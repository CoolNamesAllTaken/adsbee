#include "esp32_flasher.hh"

#include <inttypes.h>  // For PRIx32, PRIu32.
#include <string.h>    // For memcpy.

#include "binaries.c"
#include "comms.hh"
#include "esp_serial_flasher/esp_loader.h"
#include "esp_serial_flasher/esp_loader_io.h"

// #include "esp_serial_flasher/esp_common.h"

#define BIN_FIRST_SEGMENT_OFFSET 0x18
// Maximum block sized for RAM and Flash writes, respectively.
#define ESP_RAM_BLOCK            0x1800

// For esp8266, esp32, esp32s2
#define BOOTLOADER_ADDRESS_V0    0x1000
// For esp32s3 and later chips
#define BOOTLOADER_ADDRESS_V1    0x0
#define PARTITION_ADDRESS        0x8000
#define APPLICATION_ADDRESS      0x10000

typedef struct {
    const uint8_t *data;
    uint32_t size;
    uint32_t addr;
} partition_attr_t;

typedef struct {
    partition_attr_t boot;
    partition_attr_t part;
    partition_attr_t app;
} esp_binaries_t;

typedef struct {
    partition_attr_t ram_app;
} esp_ram_app_binary_t;

/**
 * @brief esptool portable bin header format
 */
typedef struct esp_bin_header {
    uint8_t magic;
    uint8_t segments;
    uint8_t flash_mode;
    uint8_t flash_size_freq;
    uint32_t entrypoint;
} esp_bin_header_t;

/**
 * @brief esptool portable bin segment format
 */
typedef struct esp_bin_segment {
    uint32_t addr;
    uint32_t size;
    uint8_t *data;
} esp_bin_segment_t;

void get_esp_binaries(target_chip_t target, esp_binaries_t *binaries);
void get_esp_ram_app_binary(target_chip_t target, esp_ram_app_binary_t *bin);
esp_loader_error_t connect_to_target(uint32_t higher_transmission_rate);
esp_loader_error_t connect_to_target_with_stub(uint32_t current_transmission_rate, uint32_t higher_transmission_rate);
esp_loader_error_t flash_binary(const uint8_t *bin, size_t size, size_t address);
esp_loader_error_t load_ram_binary(const uint8_t *bin);

// Binary arrays for each file chunk are included from binaries.c, which is auto-generated by
// esp32_flasher/bin2array.cmake, which is called by the top level CMakeLists.txt.
esp_binaries_t bin = {
    .boot = {.data = bootloader_bin, .size = bootloader_bin_size, .addr = BOOTLOADER_ADDRESS_V1},
    .part = {.data = partition_table_bin, .size = partition_table_bin_size, .addr = PARTITION_ADDRESS},
    .app = {.data = adsbee_esp_bin, .size = adsbee_esp_bin_size, .addr = APPLICATION_ADDRESS}};

bool ESP32SerialFlasher::FlashESP32() {
    CONSOLE_INFO("ESP32SerialFlasher::FlashESP32", "Beginning serial initialization.");
    Init();
    if (connect_to_target(config_.esp32_higher_baudrate) == ESP_LOADER_SUCCESS) {
        CONSOLE_INFO("ESP32SerialFlasher::FlashESP32", "Connected to target.");

        flash_binary(bin.boot.data, bin.boot.size, bin.boot.addr);
        flash_binary(bin.part.data, bin.part.size, bin.part.addr);
        flash_binary(bin.app.data, bin.app.size, bin.app.addr);
        CONSOLE_INFO("ESP32SerialFlasher::FlashESP32", "Firmware upload complete.");
    } else {
        CONSOLE_ERROR("ESP32SerialFlasher::FlashESP32", "Serial initialization failed.");
    }
    ResetTarget();
    DeInit();

    return true;
}

#if SERIAL_FLASHER_DEBUG_TRACE
static void transfer_debug_print(const uint8_t *data, uint16_t size, bool write) {
    static bool write_prev = false;

    if (write_prev != write) {
        write_prev = write;
        CONSOLE_PRINTF("\n--- %s ---\n", write ? "WRITE" : "READ");
    }

    for (uint32_t i = 0; i < size; i++) {
        CONSOLE_PRINTF("%02x ", data[i]);
    }
}
#endif

static uint32_t s_time_end;

esp_loader_error_t loader_port_write(const uint8_t *data, uint16_t size, uint32_t timeout) {
    ESP32SerialFlasher::ESP32SerialFlasherStatus status = esp32_flasher.SerialWrite((uint8_t *)data, size, timeout);

    if (status == ESP32SerialFlasher::kESP32FlasherOkay) {
#if SERIAL_FLASHER_DEBUG_TRACE
        transfer_debug_print(data, size, true);
#endif
        return ESP_LOADER_SUCCESS;
    } else if (status == ESP32SerialFlasher::kESP32FlasherErrorTimeout) {
        return ESP_LOADER_ERROR_TIMEOUT;
    } else {
        return ESP_LOADER_ERROR_FAIL;
    }
}

esp_loader_error_t loader_port_read(uint8_t *data, uint16_t size, uint32_t timeout) {
    ESP32SerialFlasher::ESP32SerialFlasherStatus status = esp32_flasher.SerialRead((uint8_t *)data, size, timeout);

    if (status == ESP32SerialFlasher::kESP32FlasherOkay) {
#if SERIAL_FLASHER_DEBUG_TRACE
        transfer_debug_print(data, size, false);
#endif
        return ESP_LOADER_SUCCESS;
    } else if (status == ESP32SerialFlasher::kESP32FlasherErrorTimeout) {
        return ESP_LOADER_ERROR_TIMEOUT;
    } else {
        return ESP_LOADER_ERROR_FAIL;
    }
}

void loader_port_enter_bootloader(void) { esp32_flasher.EnterBootloader(); }

void loader_port_delay_ms(uint32_t ms) { busy_wait_ms(ms); }

void loader_port_start_timer(uint32_t ms) { s_time_end = get_time_since_boot_ms() + ms; }

uint32_t loader_port_remaining_time(void) {
    int32_t remaining = s_time_end - get_time_since_boot_ms();
    return (remaining > 0) ? (uint32_t)remaining : 0;
}

esp_loader_error_t loader_port_change_transmission_rate(uint32_t baudrate) {
    esp32_flasher.SetBaudRate(baudrate);
    return ESP_LOADER_SUCCESS;  // Pico doesn't have a meaningful way to fail when setting baudrate.
}

void loader_port_debug_print(const char *str) { CONSOLE_INFO("esp32_flasher.cc", "DEBUG: %s", str); }

/** Begin code from example_common.c **/

esp_loader_error_t connect_to_target(uint32_t higher_transmission_rate) {
    esp_loader_connect_args_t connect_config = ESP_LOADER_CONNECT_DEFAULT();

    esp_loader_error_t err = esp_loader_connect(&connect_config);
    if (err != ESP_LOADER_SUCCESS) {
        CONSOLE_PRINTF("Cannot connect to target. Error: %u\n", err);
        return err;
    }
    CONSOLE_PRINTF("Connected to target\n");

#if (defined SERIAL_FLASHER_INTERFACE_UART) || (defined SERIAL_FLASHER_INTERFACE_USB)
    if (higher_transmission_rate && esp_loader_get_target() != ESP8266_CHIP) {
        err = esp_loader_change_transmission_rate(higher_transmission_rate);
        if (err == ESP_LOADER_ERROR_UNSUPPORTED_FUNC) {
            CONSOLE_PRINTF("ESP8266 does not support change transmission rate command.");
            return err;
        } else if (err != ESP_LOADER_SUCCESS) {
            CONSOLE_PRINTF("Unable to change transmission rate on target.");
            return err;
        } else {
            err = loader_port_change_transmission_rate(higher_transmission_rate);
            if (err != ESP_LOADER_SUCCESS) {
                CONSOLE_PRINTF("Unable to change transmission rate.");
                return err;
            }
            CONSOLE_PRINTF("Transmission rate changed to %d baud.\n", higher_transmission_rate);
        }
    }
#endif /* SERIAL_FLASHER_INTERFACE_UART || SERIAL_FLASHER_INTERFACE_USB */

    return ESP_LOADER_SUCCESS;
}

#if (defined SERIAL_FLASHER_INTERFACE_UART) || (defined SERIAL_FLASHER_INTERFACE_USB)
esp_loader_error_t flash_binary(const uint8_t *bin, size_t size, size_t address) {
    esp_loader_error_t err;
    static uint8_t payload[1024];
    const uint8_t *bin_addr = bin;

    CONSOLE_PRINTF("Erasing flash (this may take a while)...\n");
    err = esp_loader_flash_start(address, size, sizeof(payload));
    if (err != ESP_LOADER_SUCCESS) {
        CONSOLE_PRINTF("Erasing flash failed with error %d.\n", err);
        return err;
    }
    CONSOLE_PRINTF("Start programming\n");

    size_t binary_size = size;
    size_t written = 0;

    while (size > 0) {
        size_t to_read = MIN(size, sizeof(payload));
        memcpy(payload, bin_addr, to_read);

        CONSOLE_PRINTF("\nAttempting to write %d Bytes to address 0x%x.", to_read, address + binary_size - size);
        err = esp_loader_flash_write(payload, to_read);
        if (err != ESP_LOADER_SUCCESS) {
            CONSOLE_PRINTF("\nPacket could not be written! Error %d.\n", err);
            return err;
        }

        size -= to_read;
        bin_addr += to_read;
        written += to_read;

        int progress = (int)(((float)written / binary_size) * 100);
        CONSOLE_PRINTF("\rProgress: %d %%", progress);
        // fflush(stdout);
    };

    CONSOLE_PRINTF("\nFinished programming\n");

#if MD5_ENABLED
    err = esp_loader_flash_verify();
    if (err == ESP_LOADER_ERROR_UNSUPPORTED_FUNC) {
        CONSOLE_PRINTF("ESP8266 does not support flash verify command.");
        return err;
    } else if (err != ESP_LOADER_SUCCESS) {
        CONSOLE_PRINTF("MD5 does not match. err: %d\n", err);
        return err;
    }
    CONSOLE_PRINTF("Flash verified\n");
#endif

    return ESP_LOADER_SUCCESS;
}
#endif /* SERIAL_FLASHER_INTERFACE_UART || SERIAL_FLASHER_INTERFACE_USB */

esp_loader_error_t load_ram_binary(const uint8_t *bin) {
    CONSOLE_PRINTF("Start loading\n");
    esp_loader_error_t err;
    const esp_loader_bin_header_t *header = (const esp_loader_bin_header_t *)bin;
    esp_loader_bin_segment_t segments[header->segments];

    // Parse segments
    uint32_t seg;
    uint32_t *cur_seg_pos;
    for (seg = 0, cur_seg_pos = (uint32_t *)(&bin[BIN_FIRST_SEGMENT_OFFSET]); seg < header->segments; seg++) {
        segments[seg].addr = *cur_seg_pos++;
        segments[seg].size = *cur_seg_pos++;
        segments[seg].data = (uint8_t *)cur_seg_pos;
        cur_seg_pos += (segments[seg].size) / 4;
    }

    // Download segments
    for (seg = 0; seg < header->segments; seg++) {
        CONSOLE_PRINTF("Downloading %" PRIu32 " bytes at 0x%08" PRIx32 "...\n", segments[seg].size, segments[seg].addr);

        err = esp_loader_mem_start(segments[seg].addr, segments[seg].size, ESP_RAM_BLOCK);
        if (err != ESP_LOADER_SUCCESS) {
            CONSOLE_PRINTF("Loading ram start with error %d.\n", err);
            return err;
        }

        size_t remain_size = segments[seg].size;
        uint8_t *data_pos = segments[seg].data;
        while (remain_size > 0) {
            size_t data_size = MIN(ESP_RAM_BLOCK, remain_size);
            err = esp_loader_mem_write(data_pos, data_size);
            if (err != ESP_LOADER_SUCCESS) {
                CONSOLE_PRINTF("\nPacket could not be written! Error %d.\n", err);
                return err;
            }
            data_pos += data_size;
            remain_size -= data_size;
        }
    }

    err = esp_loader_mem_finish(header->entrypoint);
    if (err != ESP_LOADER_SUCCESS) {
        CONSOLE_PRINTF("\nLoad ram finish with Error %d.\n", err);
        return err;
    }
    CONSOLE_PRINTF("\nFinished loading\n");

    return ESP_LOADER_SUCCESS;
}