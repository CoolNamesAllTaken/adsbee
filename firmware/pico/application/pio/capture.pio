; PIO0
; SM0: Well Formed Preamble Detector #1
; SM1: High Power Preamble Detector #1
; SM2: Well Formed Preamble Detector #2
; SM3: High Power Preamble Detector #2

; PIO1
; SM0: Demodulator for Well Formed Preamble Detector #1
; SM1: Demodulator for High Power Preamble Detector #1
; SM2: Demodulator for Well Formed Preamble Detector #2
; SM3: Demodulator for High Power Preamble Detector #2

.program preamble_detector

; This program runs at 48MHz. Each clock cycle is 1/48us.

.define pulses_gpio 19
.define pulses_pin_index 0
.define demod_pin_index 1

; 1/8us per tick (2x 16MHz instructions per tick)
.define end_of_message_idle_ticks 20

; Allow side-setting the out_pin for debugging. 1x output pin can be optionally side-set.
.side_set 1 opt


; Build preamble pattern and load it into ISR: 0b101000010100000.
; Note that one 0 bit has been removed from the preamble to allow more cycles for the demodulator to turn on.
; set pins 0 ; DEBUG

; BEGIN DOUBLE PULSE MATCH
.wrap_target
; This is where we go to start looking for a new preamble, or after a preamble match fails.
public follow_irq:
    mov osr isr      ;side 0               ; -4 | OSR = 0b00000000000000000010100001010000
    out null 18                     ; -3 | OSR = 0b10100001010000
    mov x null                      ; -2 | Clear out x from last sampling adventure.
; Grab a new bit every 24 cycles.
;   6 cycles: Get bit.
;   12 cycles: Assert bit.
;   6 cycles: nop.
    wait 1 irq 4 rel ; Wait for IRQ 4+SM, then clear it.
waiting_for_idle:
    wait 0 gpio, pulses_gpio ; -1 | Wait for line to go LO so that we don't double with the detector that's already running.
    wait 1 gpio, pulses_gpio   ; 0 | wait for in_pin to go HI
    irq set 6 rel ;side 1 ; 1 | set IRQ 5+SM to indicate to the other preamble detector that it can start looking now
check_next_bit:
    jmp !osre preamble_not_done_yet ; 2 
    nop [7] ; 3:10 | Preamble matched! Wait till first sample point.
preamble_matched:
    set pins 1 [2] ; 3:5 | set demod pin to indicate message body beginning
    wait 1 gpio, pulses_gpio [7] ; 6:17 | wait till middle of message eye to look for end
    nop [3]
waiting_for_end_of_message:
    set x, end_of_message_idle_ticks [2] ; 18:20 | [2.0us] number of sequential idle samples required to mark end of packet
idle_countdown:
    jmp pin waiting_for_end_of_message [2] ; 21+2n:24+2n | start over the idle countdown if received a non idle bit
    jmp x-- idle_countdown [2] ; 25+2n:28+2n | still idle, keep counting down if the timer isn't up
message_finished:
    set pins, 0 ; 29+2n | set demod pin to 0 to indicate message is finished
    irq wait 0 rel ; 30+2n | Set IRQ 0+SM, and wait for it to clear (don't look for new messages until the current one has been processed).    
.wrap

preamble_not_done_yet:
    ; set x 3                         ; 3: (filter_num_samples-1) Assert HI for 12 cycles ((x+1) * (3 cycles per wrap))
    out y, 1                        ; 3: Find next bit polarity from OSR.
    jmp !y filter_pin_lo            ; 4:

; Subroutines

assert_pin_hi:
    set x 5 [1] ; 5-6 | Assert HI for 12 cycles ((x+1) * (2 cycles per wrap))
aph_wrap:
    jmp pin aph_pin_is_hi side 1 ; 7+2n
    jmp follow_irq ; 8+2n | Pin is LO, assert failed.
aph_pin_is_hi:
    jmp x-- aph_wrap side 0; 8+2n
    jmp check_next_bit [5]   ; 20-25 | cycle idle at end

; filter_pin_hi:
;     set y 3  ; 6: (filter_correct_samples-1) Minimum number of correct samples needed to keep looking.
; fph_wrap_target:
;     jmp pin fph_pin_hi  ; 7+3n
; fph_pin_lo:
;     jmp fph_wrap    ; 8+3n
; fph_pin_hi:
;     jmp y-- fph_wrap    ; 8+3n
; fph_exit_success:
;     jmp x-- fph_exit_success [2] ; Complete remaining loops.
;     jmp check_next_bit [3] ; 22-25
; fph_wrap:
;     jmp x-- fph_wrap_target ; 9+3n
;     jmp waiting_for_first_edge  ; Correlation failed.
    
filter_pin_lo:
    ; Generous implementation that accepts a single LO sample anywhere in the sampling window as a success.
    ; This accounts for the asymmetric nature of the data slicer circuit as it is charging up during the preamble; it
    ; is a lot harder to get a LO sample than a HI sample from an incoming message.
    set x 5 [2] side 1; 6-8: Number of samples = x+1.
fpl_wrap_target:
    jmp pin fpl_pin_hi side 0 ; 9+2n
fpl_pin_lo:
    jmp x-- fpl_pin_lo [1] side 1; 10+2n,11+2n | Complete remaining loops
    jmp check_next_bit [4] side 0; 20-25
fpl_pin_hi:
    jmp x-- fpl_wrap_target side 1; 8+2n
    jmp follow_irq side 0; Never found a LO sample, correlation failed.

    ; Single sample implementaiton that samples once in the middle of the interval.
;     nop [6] ; 6-12
;     jmp pin fpl_fail ; 13
; fpl_success:
;     jmp check_next_bit [11] ; 14-25
; fpl_fail:
;     jmp check_next_bit [11] ; 14-25

    ; Correlation implementation that enforces no more than y+1 samples must be incorrect (HI).
;     set y 1  ; 6: (filter_num_samples - filter_correct_samples - 1) Minimum number of INCORRECT samples needed to abort.
; fpl_wrap_target:
;     jmp pin fpl_pin_hi ; 7+3n
; fpl_pin_lo:
;     jmp fpl_wrap ; 8+3n
; fpl_pin_hi:
;     jmp y-- fpl_wrap ; 8+3n
;     jmp waiting_for_first_edge
; fpl_wrap:
;     jmp x-- fpl_wrap_target ; 9+3n
;     ; jmp !y waiting_for_first_edge ; 22: Reset if correlation failed.
;     jmp check_next_bit [3] ; 22-25



% c-sdk {

// Helper function (for use in C program) to initialize this PIO program
void preamble_detector_program_init(
    PIO pio, 
    uint sm, 
    uint offset, 
    uint pulses_pin, 
    uint demod_pin, 
    uint recovered_clk_pin,
    float div, 
    bool waiting
) {

    // Sets up state machine and wrap target. This function is automatically
    // generated in preamble_detector.pio.h.
    pio_sm_config c = preamble_detector_program_get_default_config(offset);

    // Allow PIO to read GPIO pulses_pin (as input)
    pio_sm_set_consecutive_pindirs(pio, sm, pulses_pin, 1, false); // set one pin starting at pulses_pin to IN

    // Allow PIO to control GPIO demod_pin (as output for debugging)
    pio_gpio_init(pio, demod_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, demod_pin, 1, true); // set one pin starting at demod_pin to OUT

    // Connect pulses_pin to IN pin (control with 'in' instruction)
    sm_config_set_in_pins(&c, pulses_pin); // for WAIT
    sm_config_set_jmp_pin(&c, pulses_pin); // for JMP

    // Connect demod_pin to SET
    sm_config_set_set_pins(&c, demod_pin, 1); // set one pin as SET output

    sm_config_set_out_shift(&c, false, false, 32); // OSR shifts left, autopull threshold set to 32 (used for OSRE compare)
    sm_config_set_in_shift(&c, false, false, 32); // ISR shifts left, autopush turned off
    
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);

    if (recovered_clk_pin != UINT16_MAX) {
        // This is the chosen state machine to have a recovered_clk output!

        // Allow PIO to control recovered_clk_pin (as output for debugging).
        pio_gpio_init(pio, recovered_clk_pin);
        pio_sm_set_consecutive_pindirs(pio, sm, recovered_clk_pin, 1, true); // set one pin starting at out_pin to OUT

        // Connect out_pin to SET and SIDESET
        sm_config_set_sideset_pins(&c, recovered_clk_pin); 
    }

    // Load configuration and jump to start of the program
    if (!waiting) {
        pio_sm_exec(pio, sm, pio_encode_irq_set(true, 4)); // Set IRQ 4 + SM to avoid waiting on complementary state machine on startup.
    }
    pio_sm_init(pio, sm, offset + preamble_detector_offset_follow_irq, &c);
}

%}

.program message_demodulator
; Demod pin for knowing when a valid message demod interval has begun.
.define demod_in_pin_index 0
; Demod pin for high power preamble detector. Using GPIO 29, pulses pin on GPIO 19 is base.
.define high_power_demod_in_pin_index 10
; Pulses input pin for reading current power level.
.define pulses_gpio 19
; Number of delay loops the clock recovery routine can wait, per bit, for the next manchester edge, before skipping.
; 1/24us per cycle (2x 48MHz instructions per cycle)
.define max_clock_skew_cycles 3
; Allow side-setting the out_pin for debugging. 1x output pin can be optionally side-set.
.side_set 1 opt
; Assumes line is idle low, first bit is 0
; One bit is 48 cycles
; a '0' is encoded as 01
; a '1' is encoded as 10
;
; Both the IN base and the JMP pin mapping must be pointed at the GPIO used for RX.
; Autopush must be enabled.
; Before enabling the SM, it should be placed in a 'wait 1, pin` state, so that
; it will not start sampling until the initial line idle state ends.


; SAMPLE SUBROUTINE
; Samples 5x and uses a majority vote to determine whether it's HI or LO.
; @param[in] y Goes back to end_of_0 if y = 0, goes back to end_of_1 otherwise.
; @retval x x=1 if >=2/3 samples were LO, x=0 otherwise.
sample:
    set x 4 [7]         ; 5:13 | (x+1) = number of samples to take (added delay 7)
    mov osr !null [7]   ; 14:22 | OSR = 0b1111111111111111111111 (added delay 7)
    out null 30 [2]         ; 23:25 | OSR = 0b11 (3 bits required to classify sampling period as HI)
    ; nop [2]             ; 2:7 | This delay controls max allowable clock skew per bit.
; One sample takes 3 cycles.
sample_wrap_target:
    jmp pin sample_hi side 1 ; 8+3n
sample_lo:
    jmp sample_wrap ; 9+3n
sample_hi:
    out null 1 ; 9+3n
sample_wrap:
    jmp x-- sample_wrap_target side 0 ; 10+3n
    mov x, pins [1]; 17 | read pulses and demod bit into x
    ; wait 1 pin demod_in_pin_index ; 18 | bail into idle state if demod bit is 0
    jmp !osre sample_net_lo ; 19 | used to have no delay

sample_net_hi:
    set x 0 ; 20
    jmp sample_return ; 21
sample_net_lo:
    set x 1 [1] ; 20-21
    
sample_return:
    jmp !y end_of_0 ; 22 | End of 0
    jmp end_of_1  ; 23 | End of 1

public initial_entry:
    wait 1 pin demod_in_pin_index [6] side 0   ; -11:-5 | Wait to enter DEMOD interval.
    pull noblock        ; -4 | Pull from TX FIFO to OSR in order to signal DMA to capture timestamp.
    ; Preamble ends LO, so imitate the end of a 1 with its HI->LO transition.
    jmp initial_entry_cut_in [5]            ; -3:2 | wait adjusted here

start_of_1:
    ; wait 0 gpio pulses_gpio ; 0 | Wait for the 1->0 transition - at this point we are 0.5 into the bit.
    set x max_clock_skew_cycles
start_of_1_wait_loop:
    jmp x-- falling_edge_1
    jmp pin start_of_1_wait_loop ; 0
falling_edge_1:
    mov x !null side 1          ; 1
    in x, 1 side 0              ; 2 | Emit a 1.
initial_entry_cut_in:
    set y 1 side 1              ; 3
    jmp sample side 0           ; 4
end_of_1:
    jmp !x start_of_1           ; 24 | If signal is 1 again, it's another 1 bit, otherwise it's a 0.

.wrap_target
start_of_0:                     ; We are 0.25 bits into a 0 - signal is LO
    ; wait 1 gpio pulses_gpio ; 0 | Wait for the 0->1 transition - at this point we are 0.5 into the bit.
    set x max_clock_skew_cycles
start_of_0_wait_loop:
    jmp pin rising_edge_0       ; 0
    jmp x-- start_of_0_wait_loop
rising_edge_0:
    in null, 1 [1] side 1       ; 1:2 | Emit a 0, sleep 3/4 of a bit

    set y 0 side 0              ; 3
    jmp sample                  ; 4
end_of_0:
    jmp !x start_of_1 [1]       ; 23:24 | If signal is 0 again, it's another 0 bit otherwise it's a 1
.wrap

% c-sdk {
static inline void message_demodulator_program_init(
    PIO pio, 
    uint sm, 
    uint offset, 
    uint pulses_pin, 
    uint demod_pin,
    uint recovered_clk_pin, 
    float div
) {
    pio_sm_set_consecutive_pindirs(pio, sm, demod_pin, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pulses_pin, 1, false);

    pio_sm_config c = message_demodulator_program_get_default_config(offset);
    sm_config_set_in_pins(&c, demod_pin); // WAIT pins: Utilize demod_pin as GPIO base.
    sm_config_set_jmp_pin(&c, pulses_pin); // JMP based on the comparator output
    sm_config_set_out_shift(&c, false, false, 32); // OSR shifts left, autopull turned off, autopull threshold 32 bits
    sm_config_set_in_shift(&c, false, true, 32); // ISR shifts left, autopush turned on, autopush threshold 32 bits
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE); // We expect max 112 bits, so 4 Byte RX FIFO is fine. We use the TX FIFO for DMA signaling.
    sm_config_set_clkdiv(&c, div);

    if (recovered_clk_pin != UINT16_MAX) {
        // This is the chosen state machine to have a recovered_clk output!

        // Allow PIO to control recovered_clk_pin (as output for debugging).
        pio_gpio_init(pio, recovered_clk_pin);
        pio_sm_set_consecutive_pindirs(pio, sm, recovered_clk_pin, 1, true); // set one pin starting at out_pin to OUT

        // Connect out_pin to SET and SIDESET
        sm_config_set_set_pins(&c, recovered_clk_pin, 1); // set one pin as SET output
        sm_config_set_sideset_pins(&c, recovered_clk_pin); 
    }

    pio_sm_init(pio, sm, offset, &c);
}
%}