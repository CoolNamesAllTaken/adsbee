BITS_PER_BYTE = 8

def generate_byte_reflection_table():
    """
    Generate a byte reflection table.
    @retval The byte reflection table as a list of integers.
    """
    table = []
    for i in range(256):
        reflected = 0
        for j in range(BITS_PER_BYTE):
            if i & (1 << j):
                reflected |= (1 << (BITS_PER_BYTE - 1 - j))
        table.append(reflected)
    return table

def generate_crc_table(generator, crc_len_bits):
    """
    Generate a CRC table for a given generator polynomial and bit length.
    @param generator The generator polynomial.
    @param crc_len_bits The number of crc_len_bits in the CRC.
    @retval The CRC table as a list of CRC values.
    """
    table = []
    mask = (1 << crc_len_bits) - 1  # Create mask of required length
    top_bit = 1 << (crc_len_bits - 1)
    
    for i in range(256):
        crc = i << (crc_len_bits - 8)  # Shift input byte to top of register
        # Process all 8 crc_len_bits of the input byte
        for _ in range(8):
            if crc & top_bit:
                crc = ((crc << 1) & mask) ^ generator
            else:
                crc = (crc << 1) & mask
        table.append(crc)
    return table

def calculate_crc_with_table(buffer, generator, initial_value, crc_len_bits, table):
    """
    Calculate the CRC for a given buffer using a specified generator polynomial and bit length.
    @param buffer The input data buffer.
    @param generator The generator polynomial.
    @param initial_value The initial CRC value.
    @param crc_len_bits The number of crc_len_bits in the CRC.
    @param table The precomputed CRC table.
    @retval The calculated CRC value.
    """
    crc = initial_value
    for byte in buffer:
        index = (crc >> (crc_len_bits - 8)) ^ byte
        crc = ((crc << 8) & ((1 << crc_len_bits) - 1)) ^ table[index]
    return crc

def generate_single_bit_error_syndrome_table(generator, initial_value, crc_len_bits, crc_table, message_len_bytes):
    """
    Generate a table for single-bit error syndromes.
    @param generator The generator polynomial.
    @param initial_value The initial CRC value.
    @param crc_len_bits The number of crc_len_bits in the CRC.
    @param crc_table The precomputed CRC table.
    @param message_len_bytes The length of the message in bytes.
    @retval The syndrome table as a list of CRC values.
    """
    assert crc_len_bits % BITS_PER_BYTE == 0, "CRC bit length must be a multiple of 8"
    crc_len_bytes = crc_len_bits // BITS_PER_BYTE
    table = []
    for i in range(message_len_bytes * BITS_PER_BYTE):
        # Create a buffer of all 0's.
        buffer = [0] * (message_len_bytes)
        # Flip the bit at index i to a 1 to simulate a single bit error.
        buffer[i // BITS_PER_BYTE] = 1 << ((BITS_PER_BYTE-1) - (i % BITS_PER_BYTE))
        # Calculate the CRC of the buffer with the bit flip. Note that if the bit flip in the CRC itself, the calculated
        # CRC will just be 0x0 (but the CRC remainder will still be affected).
        calculated_crc = calculate_crc_with_table(buffer[:-crc_len_bytes], generator, initial_value, crc_len_bits, crc_table)
        # XOR the calculated CRC with the CRC of the buffer to get the syndrome. Note that the CRC of the buffer is
        # always 0x0 unless the bit flip is in the CRC itself.
        buffer_crc = 0
        for j in range(crc_len_bytes):
            buffer_crc ^= buffer[-(j+1)] << (j * BITS_PER_BYTE)
        syndrome = calculated_crc ^ buffer_crc
        # Now the entry at table[i] tells us "what would the syndrome be if the bit at index i was flipped".
        table.append(syndrome)
    return table

def start_file():
    """
    Start the crc_tables.hh file.
    """
    with open("crc_tables.hh", "w") as f:
        f.write("// This file is auto-generated by generate_crc_tables.py.\n")
        f.write("#ifndef CRC_TABLES_HH_\n")
        f.write("#define CRC_TABLES_HH_\n\n")
        f.write("#include <cstdint>\n\n")

def end_file():
    """
    End the crc_tables.hh file.
    """
    with open("crc_tables.hh", "a") as f:
        f.write("#endif /* CRC_TABLES_HH_ */\n")

def add_generator_to_file(generator_name, generator):
    """
    Add a generator polynomial to the crc_tables.hh file.
    """
    with open("crc_tables.hh", "a") as f:
        f.write(f"static const uint32_t {generator_name} = 0x{generator:08X};\n")

def add_table_to_file(table_name, table):
    """
    Add a table to the crc_tables.hh file.
    """
    CHARS_PER_LINE = 120

    with open("crc_tables.hh", "a") as f:
        f.write(f"static const uint32_t {table_name}[{len(table)}] = " + "{\n")

        # Split the table into chunks of appropriate size to stay within CHARS_PER_LINE chars per line
        chunks = []
        current_chunk = []
        current_length = 4  # Account for initial spaces
        
        for value in table:
            item = f"0x{value:X}"
            # Add 2 for ", " except for the last item
            if current_length + len(item) + 2 > CHARS_PER_LINE:
                chunks.append(", ".join(current_chunk))
                current_chunk = [item]
                current_length = 4 + len(item)
            else:
                current_chunk.append(item)
                current_length += len(item) + 2
            
        if current_chunk:
            chunks.append(", ".join(current_chunk))
            
        f.write("    " + ",\n    ".join(chunks) + "\n")
        f.write("};\n\n")

def generate_crc_tables_hh():
    """
    Generate the crc_tables.hh file.
    """

    CRC24_GENERATOR = 0xFFF409 # Mode S CRC-24 generator.
    CRC24_INITIAL_VALUE = 0

    start_file()

    byte_reflection_table = generate_byte_reflection_table()
    add_table_to_file("byte_reflection_table", byte_reflection_table)

    crc24_table = generate_crc_table(CRC24_GENERATOR, 24)
    add_generator_to_file("crc24_generator", CRC24_GENERATOR)
    add_table_to_file("crc24_table", crc24_table)

    # Extended Squitter packets are 112 bits and include the CRC in the last 24 bits.
    crc24_single_bit_syndrome_112 = generate_single_bit_error_syndrome_table(
        CRC24_GENERATOR, CRC24_INITIAL_VALUE, 24, crc24_table, 112//BITS_PER_BYTE)
    add_table_to_file("crc24_single_bit_syndrome_112", crc24_single_bit_syndrome_112)

    # Squitter packets are 56 bits. The last 3 Bytes are the CRC xor'ed with the ICAO address.
    crc24_single_bit_syndrome_56 = generate_single_bit_error_syndrome_table(
        CRC24_GENERATOR, CRC24_INITIAL_VALUE, 24, crc24_table, 56//BITS_PER_BYTE)
    add_table_to_file("crc24_single_bit_syndrome_56", crc24_single_bit_syndrome_56)

    # Add CRC32 table and generator for calculating firmware CRCs for the CC1312.
    CRC32_GENERATOR = 0x04C11DB7 # Standard CRC-32 generator polynomial.
    crc32_table = generate_crc_table(CRC32_GENERATOR, 32)
    add_generator_to_file("crc32_generator", CRC32_GENERATOR)
    add_table_to_file("crc32_table", crc32_table)
    
    end_file()

if __name__ == "__main__":
    print("Generating crc_tables.hh...", end="")
    generate_crc_tables_hh()
    print("Done!")