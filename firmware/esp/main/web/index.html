<!DOCTYPE html>
<html>

<head>
    <title>ESP32 Web Terminal</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="terminal" onclick="focusTerminal()">
        <div id="terminal-content"></div>
        <div class="input-line">
            <span class="prompt">&gt;</span>
            <span id="current-line"></span>
            <span id="cursor"></span>
        </div>
    </div>
    <input type="text" class="hidden-input" id="hidden-input" autocomplete="off">

    <script type="module">
        const net = require('net'); // For TCP sockets.

        const TCP_SOCKET_CONFIG = {
            host: window.location.hostname,
            port: 3333,
            reconnect_interval_ms: 5000
            // timeout_ms: 5000
        };

        const terminal = document.getElementById('terminal');
        const terminalContent = document.getElementById('terminal-content');
        const currentLine = document.getElementById('current-line');
        const hiddenInput = document.getElementById('hidden-input');
        const cursor = document.getElementById('cursor');

        const client = new net.Socket();

        let socket = null;
        let commandHistory = [];
        let historyIndex = -1;
        let currentCommand = '';

        class TCPClient {
            constructor(host, port, reconnect_interval_ms) {
                this.host = host;
                this.port = port;
                this.reconnect_interval_ms = reconnect_interval_ms;
            }

            init() {
                this.client = new net.Socket();
                this.attachEventHandlers();
                this.connect();
            }

            connect() {
                this.client.connect(this.port, this.host, () => {
                    console.log(`Connected to ${this.host}:${this.port}`);

                    // Send the message
                    this.client.write("Hello world!");
                    console.log(`Sent first message.`);
                });

            }

            attachEventHandlers() {
                // Handle received data
                this.client.on('data', (data) => {
                    console.log(`Received response: ${data}`);
                    appendToTerminal(data);
                });

                // Handle connection close
                this.client.on('close', () => {
                    console.log(`Connection closed, retrying in ${TCP_SOCKET_CONFIG.reconnect_interval_ms} ms.`);
                    appendToTerminal(`Connection closed, retrying in ${TCP_SOCKET_CONFIG.reconnect_interval_ms} ms.\n`);
                    // Schedule a call to connect() in order to try again.
                    setTimeout(connect, TCP_SOCKET_CONFIG.reconnect_interval_ms);
                });

                // Handle errors
                this.client.on('error', (error) => {
                    console.error('Connection error:', error);
                    appendToTerminal('Connection error:' + error + '\n');
                    this.client.destroy();
                    // Schedule a call to connect() in order to try again.
                    setTimeout(connect, TCP_SOCKET_CONFIG.reconnect_interval_ms);
                });

                // // Set connection timeout
                // this.client.setTimeout(CONFIG.timeout);
                // this.client.on('timeout', () => {
                //     console.log('Connection timed out.');
                //     this.client.end();
                // });
            }

            attemptReconnect() {
                setTimeout(() => {
                    // Create a new socket instance
                    this.client.destroy();
                    this.init();
                }, CONFIG.reconnectDelay);
            }

        }

        function appendToTerminal(text) {
            terminalContent.innerHTML += text;
            terminal.scrollTop = terminal.scrollHeight;
        }

        function focusTerminal() {
            hiddenInput.focus();
        }

        function handleCommand(command) {
            if (command.trim()) {
                commandHistory.push(command);
                historyIndex = commandHistory.length;
                appendToTerminal('> ' + command + '\n');

                client.send(command);
            }
            currentLine.textContent = '';
            currentCommand = '';
        }

        hiddenInput.addEventListener('input', (e) => {
            currentCommand = hiddenInput.value;
            currentLine.textContent = currentCommand;
            hiddenInput.value = currentCommand;
        });

        hiddenInput.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'Enter':
                    e.preventDefault();
                    handleCommand(currentCommand);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        currentCommand = commandHistory[historyIndex];
                        currentLine.textContent = currentCommand;
                        hiddenInput.value = currentCommand;
                    }
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        currentCommand = commandHistory[historyIndex];
                    } else {
                        historyIndex = commandHistory.length;
                        currentCommand = '';
                    }
                    currentLine.textContent = currentCommand;
                    hiddenInput.value = currentCommand;
                    break;
                case 'Tab':
                    e.preventDefault();
                    // Could implement command completion here
                    break;
            }
        });

        // Handle copy/paste
        document.addEventListener('copy', (e) => {
            const selection = window.getSelection();
            if (selection.toString().length > 0) {
                e.clipboardData.setData('text/plain', selection.toString());
                e.preventDefault();
            }
        });

        document.addEventListener('paste', (e) => {
            e.preventDefault();
            const paste = e.clipboardData.getData('text');
            currentCommand += paste;
            currentLine.textContent = currentCommand;
            hiddenInput.value = currentCommand;
        });

        // Keep cursor blinking when window is inactive
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                cursor.style.animation = 'none';
                cursor.offsetHeight; // Trigger reflow
                cursor.style.animation = null;
            }
        });

        // Initialize
        connect();
        focusTerminal();
    </script>
</body>

</html>